#!/usr/bin/python3
# coding: utf-8
# -*- coding: utf-8 -*-


i = 666

print(i)

print('Hello, World!')

l = [1,2,3,4]
l2 = l
l2.append(888)
print(l)
print(l2)

i = -123 ; print(i)

print( 0b10101010)


print(13) # Число 13 записанное в десятичной форме
print(0x0d) # Число 13 записанное в шестнадцатеричном виде
print(0o15) # Число 13 в восьмеричном виде
print(0b00001101) # Число 13 в бинарном виде


print ( 12e-2, 12e-3, 12e3 )
print (12.3j) # комплексное число

print('knight"s', "knight's") # Ковычки в середине строки
print('knight\'s', "knight\"s") # экранирование ковычек слешем \

bs = b'test' ; print (bs)

# 1 = u"Unicode literal"b'
# u2 = u'\u0410\u0434\u0440\u0435\u0441'
# s5 = '\x73\65\65'
# s6 = b'sp\x01am' # Строки байтов в версии 3.0

# rs = r'\\ \"'

# print (rs)



# Кортежи


# В одинарных ковычках '' строки (str)
# В квадратных скобках [] списки (list)
# В фигурных скобках {} словари (dict)
# В круглых скобках () кортежи (tuple)



person = ('Name', 26, True, ())
print(person[2])

lst = [1, 2, 3, 4] ; print(lst)
lst[2] = 33
lst.append(5)
print(lst)

m = set()
print(m)

m = {1,5,1}
print(m)

# множества выводят уникальные значения

d = { 'username' : 'max', 'password' : "123" }
print ( d['password'] )

print ( d)

un = None ; print(un)

# тип данных узнать
print(type ( un ))
print(type ( d ))

s = 'hello'
lst = s.upper()      # Преобразование символов в верхний регистр
print (lst)

# указать систему счисления можно во 2м параметре int:
print(int('64')) # Число 64 записанное в десятичной форме
print(int('100', 8)) # число 64 в восьмеричном виде
print(int('40', 16))  # число 64 в шестнадцатеричном виде
print(int('1000000', 2)) # число 64 в бинарном виде



# Другие способы работы с двоичным представлением
print(bin(255), int('11111111',2), 0b11111111)

print( float(10) )

'''

% остаток от деления

** степень

//  деление без остатка

= += -= *= .= ..= %=


== равно
!= не равно
<> не равно 
>= больше или рано
<= меньше или равно


or and not
^


& | ~ ^ << >>



'''


a = 0b00001111 & 0b10001111 # Логическое И (AND)
print(bin(a)) # остаются только совпадающие биты: a=00001111

a = 0b00001111 | 0b10001111 # Логическое ИЛИ (OR)
print(bin(a)) # любые включённые биты остаются: a=10001111

a = 0b00001111 ^ 0b10001111 # логическое Искючающее ИЛИ (XOR)
print(bin(a)) # Совпадающие биты выключаются: a = 10000000




a = 0b00001111 << 1 ;print(bin(a))  # Побитовый сдвиг  ВЛЕВО: a=00011110
a = 0b00001111 >> 1 ;print(bin(a)) # Побитовый сдвиг ВПРАВО: a=00000111

print(
d.values(),
d.keys())

print(  type(d) is not dict) 


# Использование операции получения среза с тремя пределами для
# пропуска элементов и изменения порядка их следования.
x = '0123456789'
print(x[::]) # просто вывести как есть
print(x[:-1:]) # вывести без последнего символа
print(x[::-1]) # вывести задом-наперёд с конца к началу.
print(x[::2]) # извлечь каждый 2й символ от начала и до конца
print(x[1::2]) #  со 2го и до конца
print(x[1:5:3]) # извлечь каждый 3й символ со 2го до 5го.

# Фраза задом-наперёд
smile = 'улыбок тебе детских макар'
print(smile[::-1])


p = None
if p is not None:
    print('p существует')
else:
    print('p НЕ существует')
#elif type(p) is str:
#    print("srt")

q = 5 ** 2 if p is None else 5 ** 3
print(q)

a = '789'
a = int(a) if type(a) is str else 0
print (a)






